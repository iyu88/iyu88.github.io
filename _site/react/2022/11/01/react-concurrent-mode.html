<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>
    [React] React Concurrent Mode - Data fetching, Suspense, React hook
  </title>
  <meta name="description" content="React Concurrent Mode - Data fetching, Suspense, React hook">
  
  <meta name="author" content="Hyunbin Lee">
  <meta name="copyright" content="&copy; Hyunbin Lee 2022">
  

  <!-- External libraries -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/monokai-sublime.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css">

  <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
  <link rel="shortcut icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="manifest" href="/assets/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  

  

  

  <!-- Site styles -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/react/2022/11/01/react-concurrent-mode.html">
  <link rel="alternate" type="application/rss+xml" title="구멍을 외면하지 말자" href="http://localhost:4000/feed.xml" />

  <!-- Tooltips -->
  <script type="text/javascript">
    window.tooltips = []
  </script>
</head>

  <body>

    <header class="navigation" role="banner">
  <div class="navigation-wrapper">
    <a href="/" class="logo">
      
      <img src="/assets/logo.png" alt="구멍을 외면하지 말자">
      
    </a>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
      <i class="fa fa-bars"></i>
    </a>
    <nav role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
				
	

	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </nav>
  </div>
</header>


    <div class="page-content">
        <div class="post">

  <div class="post-header-container has-cover" style="background-image: url(/assets/instacode.png);" >
    <div class="scrim has-cover">
      <header class="post-header">
        <h1 class="title">
          [React] React Concurrent Mode - Data fetching, Suspense, React hook
        </h1>
        <p class="info">by <strong>
            Hyunbin Lee</strong></p>
      </header>
    </div>
  </div>

  <div class="wrapper">

    

    <section class="post-meta">
      <div class="post-date">
        November 1, 2022
      </div>
      <div class="post-categories">
        in 
        
        <a href="/category/React">
          React</a>
        
        
      </div>
    </section>

    <article class="post-content">
      <h1 id="react-concurrent-mode---data-fetching-suspense-react-hook">React Concurrent Mode - Data fetching, Suspense, React hook</h1>

<blockquote>
  <h3 id="-react-의-동시성-모드와-관련한-기능들에-대해서-알아봅니다">💡 React 의 동시성 모드와 관련한 기능들에 대해서 알아봅니다.</h3>
</blockquote>

<h2 id="1-react">1. React</h2>

<p>React 가 등장하기 전에 동적인 웹 프론트엔드 개발을 위해서 주로 사용되던 라이브러리는 <code class="language-plaintext highlighter-rouge">jQery</code> 였습니다. jQuery 는 브라우저에 있는 DOM 을 제어하고 이벤트를 등록하는 작업들을 편리하게 수행할 수 있도록 도와주었습니다. 하지만, jQery 는 DOM 을 다룰 때 많은 단계를 거쳐야 했기 때문에 성능 상에서 바닐라 자바스크립트보다 낮은 퍼포먼스를 보였습니다. 또한 브라우저가 다양해지면서 각 브라우저마다 지원하는 DOM API 스펙이 달라졌고, 이로 인한 웹 프론트엔드 개발의 복잡성은 증가했습니다.</p>

<p><br /></p>

<p>React 는 이러한 문제들을 해결해주었습니다. 합성 이벤트 ( Synthetic Event ) 로 브라우저의 기본 이벤트를 감싸서 개발자가 다양한 환경에 일일이 대응하지 않아도 React 에서 알아서 처리해주는 것처럼 개발의 복잡성을 줄여주었습니다. 이제 React 는 웹 프론트엔드를 개발할 때 널리 사용되고 있습니다. Single Page Application 으로 만들어서 페이지 이동 간에 별도의 reload 가 필요하지 않습니다. 이를 통해서 페이지 구성 요소를 빠르게 불러오는 웹 사이트를 만들 수 있고 이용자들에게 긍정적인 사용자 경험을 제공합니다.</p>

<hr />

<h2 id="2-데이터를-불러오는-문제">2. 데이터를 불러오는 문제</h2>

<p>앞서 페이지 이동 간에 별도의 reload 가 필요하지 않다고 했지만 서버로부터 정보를 받아서 화면에 표시하는 작업은 필수적입니다. React 로 구현한 웹 사이트의 구성 요소인 컴포넌트에서 필요한 데이터를 불러오고 이를 사용자의 화면에 DOM 을 통해서 동적으로 표시해주는 데에서 문제가 발생할 수 있습니다.</p>

<p><br /></p>

<p>일반적으로 웹 페이지에 표시할 데이터를 불러오는 작업은 컴포넌트가 마운트된 이후에 진행합니다. 이를 <code class="language-plaintext highlighter-rouge">Fetch on render</code> 라고 부릅니다. 데이터를 화면에 표시하기 위해서 클라이언트에서 모든 데이터를 받은 뒤에 DOM 을 업데이트하게 됩니다. 이러한 방식은 다음과 같은 문제 상황을 발생시킬 수 있습니다.</p>
<ul>
  <li>데이터를 불러오는 시간동안 컴포넌트 내부에 있는 데이터에 의존하는 DOM 이 존재하지 않을 수 있습니다. 따라서 사용자가 데이터와 관련된 이벤트를 발생시키지 못하거나 발생시키더라도 이를 DOM에 정상적으로 반영하지 못할 수 있습니다.</li>
  <li>또한 데이터를 다 불러온 뒤에 업데이트 되는 DOM 때문에 기존에 화면에 위치한 요소들의 좌표가 바뀌면서 Layout 을 다시 계산하는 연산을 한 번 더 수행하게 됩니다.</li>
</ul>

<p><br /></p>

<p>이처럼 데이터를 어느 시점에서 불러오는지를 결정하는 것이 또 다른 중요한 과제가 되었습니다. 더 자세한 내용은 <code class="language-plaintext highlighter-rouge">4. Data Fetching</code> 에서 살펴보도록 하겠습니다.</p>

<hr />

<h2 id="3-react-concurrent-mode">3. React Concurrent Mode</h2>

<p>데이터를 불러오는 작업을 수행하면서 React 가 주는 긍정적인 사용자 경험과 성능 상의 이점이라는 두 마리 토끼를 모두 잡아야 하는 상황이 되었습니다. 이를 위해 <code class="language-plaintext highlighter-rouge">React Concurrent Mode (동시성 모드)</code> 가 등장했습니다.</p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">동시성</code>이란 독립적으로 실행될 수 있는 작업들을 여러 조각으로 세분화하고 번갈아 가면서 실행하는 것을 말합니다. 자바스크립트는 싱글 스레드 언어이기 때문에 한 번에 하나의 작업을 수행합니다. 하지만 브라우저에서 실행되는 자바스크립트는 DOM Tree 구성, 네트워크 통신, 사용자 이벤트 처리 등 여러 가지 작업을 처리해야 합니다. 만일 하나의 작업만 수행할 수 있다면 낮은 퍼포먼스로 인해 웹 브라우저가 매우 느리다는 느낌을 받아야 하지만 실제로는 전혀 그렇지 않습니다. 브라우저는 문제 없이 위의 작업들을 동시에 처리하는 것처럼 보입니다.</p>

<p><br /></p>

<p>브라우저는 <code class="language-plaintext highlighter-rouge">이벤트 큐</code>와 <code class="language-plaintext highlighter-rouge">이벤트 루프</code>를 통해서 동시성을 유지합니다. 특정한 작업들은 자바스크립트가 처리하는 작업이 저장되는 <code class="language-plaintext highlighter-rouge">콜스택</code>에서 처리되지 않고 이벤트 큐로 이동됩니다. 이후 콜스택이 비어있는 <code class="language-plaintext highlighter-rouge">Idle</code> 상태일 때 이벤트 큐에 있는 작업들이 이벤트 루프에 의해서 콜스택으로 다시 이동하여 처리됩니다. 따라서 브라우저는 위에서 언급한 작업들을 비동기 콜백으로 실행하여 동시성을 달성합니다.</p>

<p><br /></p>

<p>React 는 렌더링 과정에서 일어나는 일들을 작은 단위로 나누고 빠른 속도로 번갈아 가면서 작업을 처리하는 동시성 모드를 지원합니다. 동시성 모드를 기존의 React 와 다른 특별한 모드로 받아들이기보다는, 문제를 해결하기 위해서 등장한 React 의 기능들이라고 이해하면 됩니다. 이와 관련한 기능과 React Hook 에 대해서 알아보기 전에 Data Fetching 방식에 대해서 짚고 넘어가겠습니다.</p>

<hr />

<h2 id="4-data-fetching">4. Data Fetching</h2>

<p>동시성 모드 기능들에 대해서 다루기 전에 일반적인 Data Fetching (데이터를 불러오는) 의 유형에 대해서 간단하게 알아보겠습니다. 다음과 같은 3가지 유형으로 나눌 수 있습니다.</p>

<ol>
  <li>Fetch on render</li>
  <li>Fetch then render</li>
  <li>Render as fetch</li>
</ol>

<p>*API 는 <a href="https://jsonplaceholder.typicode.com/photos">jsonplaceholder</a> 사이트를 사용했습니다.</p>

<h3 id="4-1-fetch-on-render">4-1) Fetch on render</h3>

<p><code class="language-plaintext highlighter-rouge">Fetch on render</code> 는 컴포넌트가 모두 마운트된 뒤에 데이터를 불러오는 작업을 수행하는 방식입니다. React 에서 useEffect Hook 을 사용하여 데이터를 모두 불러온 뒤에 state 를 변경시키고 이를 DOM 에 렌더링합니다.</p>

<p><br /></p>

<h4 id="4-1-1-데이터만-불러올-때">4-1-1) 데이터만 불러올 때</h4>

<p>API 서버로부터 받아온 정보만 화면에 렌더링하는 경우입니다. <code class="language-plaintext highlighter-rouge">/photos</code> 경로로 요청을 보내면 배열에 5천 개의 결과값을 받아옵니다.</p>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">dataUrl</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://jsonplaceholder.typicode.com/photos</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">fetchOnRender</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">axios</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">dataUrl</span><span class="p">);</span>
      <span class="nx">setDummyData</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="nx">fetchOnRender</span><span class="p">();</span>
<span class="p">},</span> <span class="p">[]);</span></code></pre></figure>

<p>컴포넌트가 마운트되었을 때 useEffect 안에서 <code class="language-plaintext highlighter-rouge">setDummyData()</code> 를 통해서 state 를 업데이트합니다. 데이터가 있을 경우에는 “데이터 로딩 중” 이라는 문자를 표시하고 데이터를 모두 받아왔을 때에는 해당 정보들을 표시하는 방식으로 구현한 결과입니다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/31645195/198887484-a8a302e8-a3a4-4dba-b15b-f4e5c08b8e4e.gif" alt="useEffect_fetch_on_render" /></p>

<p><br /></p>

<p>다음은 크롬 확장 프로그램으로 존재하는 <code class="language-plaintext highlighter-rouge">React Developer Tools</code> 에서 <code class="language-plaintext highlighter-rouge">Profiler</code> 탭에서 확인할 수 있는 타임라인입니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/198887674-ac9fe2a8-3367-4203-93c0-b8a0333bc98a.png" />
<em>4-1-1) Fetch on render / 데이터만 불러올 때</em>
<br /></p>

<p><br /></p>

<p><strong> [4-1-1) Fetch on render / 데이터만 불러올 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">13ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">3ms</td>
      <td style="text-align: center">13ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">16ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">13ms</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">24ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">13ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">85ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">49ms</td>
      <td style="text-align: center">335ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">239ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">239ms</td>
      <td style="text-align: center">335ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">419ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">335ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>Profiler 에서 제공하는 각 이벤트 종류는 다음과 같은 의미를 가지고 있습니다.</p>

<ul>
  <li>render : DOM 에 어떠한 변화가 일어나야 하는지 결정합니다. 이전의 렌더링 결과와 비교합니다.</li>
  <li>commit : React 에서 실제로 DOM 을 조작하고 변경 사항을 적용하는 단계입니다.</li>
  <li>passive-effects : useEffect 에서 정의한 작업을 동기적으로 실행하기 위해서 새로운 자바스크립트 작업 단위를 발생시킵니다. commit 을 실행한 후에 발생합니다.</li>
</ul>

<p>1번에서 3번 이벤트까지는 초기 컴포넌트가 렌더링되었을 때를 의미하고 4번에서 6번 이벤트까지는 useEffect 를 통해서 API 요청 결과가 state 에 반영되었을 때를 의미합니다.</p>

<p><br /></p>

<h4 id="4-1-2-데이터를-불러오고-이미지를-상단에-배치했을-때">4-1-2) 데이터를 불러오고 이미지를 상단에 배치했을 때</h4>

<p>동일한 API 서버로부터 정보를 받아와서 표시하지만 상단에 이미지 태그를 배치하고 난 뒤에 차이점을 살펴보았습니다.</p>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="k">return</span> <span class="p">(</span>
  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="p">=</span><span class="s">"./image.JPG"</span> <span class="na">alt</span><span class="p">=</span><span class="s">"테스트 이미지"</span> <span class="na">width</span><span class="p">=</span><span class="s">"100px"</span> <span class="p">/&gt;</span>
    <span class="si">{</span><span class="nx">dummyData</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="p">(</span>
      <span class="nx">dummyData</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">d</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nt">h4</span> <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">d</span><span class="p">.</span><span class="nx">id</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h4</span><span class="p">&gt;)</span>
    <span class="p">)</span> <span class="p">:</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span> 데이터 로딩 중...<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">)</span><span class="si">}</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">);</span></code></pre></figure>

<p>JSX 반환값에서 데이터 목록을 표시하기 전에 이미지 태그를 먼저 위치시킵니다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/31645195/198888673-ad72c76d-8a2c-403d-9185-6aa63056f8e1.gif" alt="useEffect_fetch_on_render_img_first" /></p>

<p><br /></p>

<p>위와 같이 이미지가 최상단에 위치해있고 데이터를 불러오면 이미지 아래에 렌더링하는 것을 확인할 수 있습니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/198888755-87e75e95-8ca0-4f0e-b561-36e3f4508391.png" />
<em>4-1-2) Fetch on render / 데이터를 불러오고 이미지를 상단에 배치했을 때</em>
<br /></p>

<p><br /></p>

<p><strong> [4-1-2) Fetch on render / 데이터를 불러오고 이미지를 상단에 배치했을 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">24ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">4ms</td>
      <td style="text-align: center">14ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">27ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">14ms</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">36ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">14ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">109ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">94ms</td>
      <td style="text-align: center">341ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">203ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">216ms</td>
      <td style="text-align: center">341ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">450ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">341ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="4-1-3-데이터를-불러오고-이미지를-하단에-배치했을-때">4-1-3) 데이터를 불러오고 이미지를 하단에 배치했을 때</h4>

<p><code class="language-plaintext highlighter-rouge">4-1-2)</code> 와 동일하지만 이번에는 이미지 태그를 데이터 목록 하단에 위치시키고 테스트했습니다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/31645195/198888928-f4e15e35-98ba-470f-ace4-75d35e5a8f30.gif" alt="useEffect_fetch_on_render_img_last" /></p>

<p><br /></p>

<p>초기에는 이미지가 최상단에 위치해있고 데이터가 렌더링되면 이미지가 아래로 밀려나서 화면에서 사라지는 것을 확인할 수 있습니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/198889013-09905889-bc8c-496e-b5cd-675654637223.png" />
<em>4-1-3) Fetch on render / 데이터를 불러오고 이미지를 하단에 배치했을 때</em>
<br /></p>

<p><br /></p>

<p><strong> [4-1-3) Fetch on render / 데이터를 불러오고 이미지를 하단에 배치했을 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">13ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">4ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">18ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">27ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">88ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">68ms</td>
      <td style="text-align: center">342ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">156ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">228ms</td>
      <td style="text-align: center">342ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">430ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">342ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="4-1-4-fetch-on-render-정리">4-1-4) Fetch on render 정리</h4>

<p>각각의 경우에 대해서 4번 render 이벤트와 5번 commit 이벤트에 대해서 비교해보겠습니다.</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">테스트 번호</th>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">4-1-1</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">49ms</td>
      <td style="text-align: center">335ms</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">239ms</td>
      <td style="text-align: center">335ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4-1-2</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">94ms</td>
      <td style="text-align: center">341ms</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">216ms</td>
      <td style="text-align: center">341ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4-1-3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">68ms</td>
      <td style="text-align: center">342ms</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">228ms</td>
      <td style="text-align: center">342ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>눈여겨 볼 점은 JSX 가 이미지 태그를 반환한 경우 (<code class="language-plaintext highlighter-rouge">4-1-2</code>, <code class="language-plaintext highlighter-rouge">4-1-3</code>) 가 그렇지 않은 경우보다 render 의 실행시간이 더 오래걸렸다는 것입니다. 이는 화면에 그려야 할 DOM 의 개수가 더 많기 때문이라고 해석할 수 있습니다. 일괄 처리 시간이 약 6-7ms 정도 더 걸렸다는 점도 동일한 내용으로 해석할 수 있습니다.</p>

<p><br /></p>

<p>이미지 태그가 상단에 위치한 경우와 하단에 위치한 경우의 commit 실행시간이 각각 216ms 와 228ms 로 12ms 정도 차이나는 것을 알 수 있습니다. 이미지가 하단에 위치했을 경우 데이터 목록이 상단에서부터 렌더링되면서 기존의 이미지 위치가 재계산되는 과정이 commit 단계에서 추가되었기 때문이라고 해석할 수 있습니다. Fetch on render 방식은 글 도입부에 설명했던 것처럼 느린 DOM 렌더링을 통해서 사용자가 웹 페이지와 상호작용하는 것을 방해하거나 Layout Shift 때문에 불필요한 레이아웃 좌표 계산 등의 단점이 존재합니다.</p>

<hr />

<h3 id="4-2-fetch-then-render">4-2) Fetch then render</h3>

<p>앞서 발생한 문제들은 모두 데이터를 느리게 불러올 경우 발생했습니다. 따라서 <code class="language-plaintext highlighter-rouge">Fetch then render</code> 방식에서는 데이터를 조금 더 빠르게 불러오는 방향으로 접근합니다. 바로 컴포넌트를 생성하기 전에 데이터를 미리 불러오기 시작하는 방식입니다. 따라서 이번에는 컴포넌트의 반환값은 동일하지만 데이터를 불러오는 순서가 다른 경우를 테스트합니다.</p>

<p><br /></p>

<h4 id="4-2-1-데이터만-불러올-때">4-2-1) 데이터만 불러올 때</h4>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="kd">const</span> <span class="nx">photoData</span> <span class="o">=</span> <span class="nx">fetchThenRender</span><span class="p">();</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">ChildComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">dummyData</span><span class="p">,</span> <span class="nx">setDummyData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([]);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">photoData</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setDummyData</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// (생략)</span>
<span class="p">}</span></code></pre></figure>

<p>컴포넌트 바깥에서 데이터를 불러오는 <code class="language-plaintext highlighter-rouge">fetchThenRender()</code> 함수를 호출합니다. useEffect 에서는 해당 변수에 Promise 객체가 결과를 반환할 때 state 를 업데이트해줍니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199045526-455cced8-497f-4803-bfa8-1eafe9807d7d.png" />
<em>4-2-1) Fetch then render / 데이터만 불러올 때</em>
<br /></p>

<p><br /></p>

<p><strong> [4-2-1) Fetch then render / 데이터만 불러올 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">20ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">3ms</td>
      <td style="text-align: center">8ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">23ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">8ms</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">27ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">8ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">73ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">46ms</td>
      <td style="text-align: center">292ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">119ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">214ms</td>
      <td style="text-align: center">292ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">364ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">292ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="4-2-2-데이터를-불러오고-이미지를-배치했을-때">4-2-2) 데이터를 불러오고 이미지를 배치했을 때</h4>

<p><code class="language-plaintext highlighter-rouge">4-1-2)</code> &amp; <code class="language-plaintext highlighter-rouge">4-1-3)</code> 과 동일하게 이미지 태그를 배치했을 경우에 대해서도 테스트해보았습니다. 해당 태그를 데이터 목록의 각각 상단과 하단에 위치시켰을 때의 결과값은 다음과 같습니다.</p>

<p><br /></p>

<p><strong> [이미지가 데이터 목록 상단에 있을 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">25ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">3ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">28ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">41ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">94ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">42ms</td>
      <td style="text-align: center">241ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">135ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">166ms</td>
      <td style="text-align: center">241ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">335ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">241ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong> [이미지가 데이터 목록 하단에 있을 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">25ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">3ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">28ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">42ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">17ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">111ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">42ms</td>
      <td style="text-align: center">210ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">153ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">155ms</td>
      <td style="text-align: center">210ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">321ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">210ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="4-2-3-fetch-then-render-정리">4-2-3) Fetch then render 정리</h4>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">테스트 번호</th>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">4-2-1</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">46ms</td>
      <td style="text-align: center">292ms</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">214ms</td>
      <td style="text-align: center">292ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4-2-2 (상단)</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">42ms</td>
      <td style="text-align: center">241ms</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">166ms</td>
      <td style="text-align: center">241ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4-2-2 (하단)</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">42ms</td>
      <td style="text-align: center">210ms</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">155ms</td>
      <td style="text-align: center">210ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>주목할 부분은 위의 세 가지 경우의 render 와 commit 실행시간이 모두 <code class="language-plaintext highlighter-rouge">4-1) Fetch on render</code> 의 실행시간보다 짧게 걸렸다는 점입니다. render 의 경우에는 적게는 3ms 에서 많게는 약 48ms 정도 빠릅니다. 또한 commit 의 경우에도 적게는 2ms 에서 많게는 약 84ms 정도 실행시간이 줄어든 것을 확인할 수 있습니다.</p>

<p><br /></p>

<h4 id="4-2-4-데이터를-두-개-불러올-때">4-2-4) 데이터를 두 개 불러올 때</h4>

<p>Fetch then render 는 데이터 로딩을 빠르게 시작한다는 점에서 Layout Shift 가 발생할 가능성이 적습니다. 하지만 또 다른 문제 상황이 존재합니다. 바로 데이터를 여러 개 불러오는 경우입니다. 데이터를 미리 불러온다는 개념을 유지하면서 여러 개의 데이터를 받아와야 하는 경우도 살펴보겠습니다.</p>

<p>이전까지 photos 데이터를 받아오기 위해서 API 요청을 한 번만 보냈다면, 5백 개의 comments 데이터까지 받아오기 위해서 추가적인 API 요청을 보냅니다.</p>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="kd">const</span> <span class="nx">fetchDummyData</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
    <span class="nx">fetchThenRender</span><span class="p">(</span><span class="dl">"</span><span class="s2">photos</span><span class="dl">"</span><span class="p">),</span>
    <span class="nx">fetchThenRender</span><span class="p">(</span><span class="dl">"</span><span class="s2">comments</span><span class="dl">"</span><span class="p">),</span>
  <span class="p">]).</span><span class="nx">then</span><span class="p">(([</span><span class="nx">photos</span><span class="p">,</span> <span class="nx">comments</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">photos</span><span class="p">,</span> <span class="nx">comments</span><span class="p">]);</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">dummyData</span> <span class="o">=</span> <span class="nx">fetchDummyData</span><span class="p">();</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">ChildComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">dummyPhotoData</span><span class="p">,</span> <span class="nx">setDummyPhotoData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([]);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">dummyCommentData</span><span class="p">,</span> <span class="nx">setDummyCommentData</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([]);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">dummyData</span><span class="p">.</span><span class="nx">then</span><span class="p">(([</span><span class="nx">photos</span><span class="p">,</span> <span class="nx">comments</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setDummyPhotoData</span><span class="p">(</span><span class="nx">photos</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
      <span class="nx">setDummyCommentData</span><span class="p">(</span><span class="nx">comments</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// (생략);</span>
<span class="p">}</span></code></pre></figure>

<p>Promise.all() 을 사용하여 photos 와 comments 에 대한 응답을 하나의 변수에 저장합니다. useEffect 에서 각 state 를 업데이트합니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199139903-381bf13d-2eda-454d-87c5-588034ad30d6.png" />
<em>4-2-3) Fetch then render / 데이터를 두 개 불러올 때</em>
<br /></p>

<p><br /></p>

<p><strong> [4-2-3) Fetch then render / 데이터를 두 개 불러올 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">14ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">3ms</td>
      <td style="text-align: center">16ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">17ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">16ms</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">30ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">16ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">151ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">54ms</td>
      <td style="text-align: center">244ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">205ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">177ms</td>
      <td style="text-align: center">244ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">394ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">244ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>이러한 방식은 컴포넌트에 필요한 모든 데이터를 받을 때까지 기다려야 한다는 단점이 존재합니다. comments 데이터의 개수가 적기 때문에 데이터를 상대적으로 일찍 받아서 빠르게 DOM 을 업데이트하는 것을 기대할 수 있습니다. 하지만 Promise.all() 을 통해서 모든 데이터를 받아와야 값을 반환할 수 있기 때문에 아무리 comments 를 먼저 불러왔어도 photos 데이터를 다 받아오기 전까지 DOM 이 업데이트 되지 않습니다.</p>

<p><br /></p>

<p>한편 Promise.all() 을 사용하지 않고 개별적인 함수로 데이터를 받아오는 방식을 사용할 수도 있습니다. 다만 서로 다른 데이터 종류가 여러 개 존재할 경우 컴포넌트 선언 전에 작성하는 코드가 길어지거나 관리해야 할 함수가 많아진다는 단점이 존재합니다.</p>

<hr />

<h3 id="4-3-render-as-fetch">4-3) Render as fetch</h3>

<p>지금까지 컴포넌트를 먼저 불러오면 DOM 이 느리게 업데이트되고 데이터를 먼저 불러오면 여러 개의 요청을 보낼 때 문제가 발생할 수 있다는 것을 확인했습니다. 이러한 딜레마를 해결하기 위한 방법으로 React Concurrent Mode 에서는 <code class="language-plaintext highlighter-rouge">Suspense</code> 라는 기능을 제공합니다. Suspense 를 사용하면 컴포넌트 렌더링과 동시에 데이터를 받아오기 시작합니다. 또한 Suspense 의 fallback 속성을 사용하여 데이터를 로딩하는 시간동안 화면에 표시할 DOM 을 정의할 수 있습니다.</p>

<p><br /></p>

<h4 id="4-3-1-suspense-를-사용할-때">4-3-1) Suspense 를 사용할 때</h4>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="kd">const</span> <span class="nx">wrapPromise</span> <span class="o">=</span> <span class="p">(</span><span class="nx">promise</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">pending</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">response</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">suspender</span> <span class="o">=</span> <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">;</span>
      <span class="nx">response</span> <span class="o">=</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">;</span>
      <span class="nx">response</span> <span class="o">=</span> <span class="nx">err</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">);</span>

  <span class="kd">const</span> <span class="nx">read</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="dl">"</span><span class="s2">pending</span><span class="dl">"</span><span class="p">:</span>
        <span class="k">throw</span> <span class="nx">suspender</span><span class="p">;</span>
      <span class="k">case</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">:</span>
        <span class="k">throw</span> <span class="nx">response</span><span class="p">;</span>
      <span class="nl">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">response</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="p">{</span> <span class="nx">read</span> <span class="p">};</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">fetchDummyData</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">requestURL</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://jsonplaceholder.typicode.com/photos</span><span class="dl">"</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">axios</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">requestURL</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">wrapPromise</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>위 코드에서 각 함수의 역할은 다음과 같습니다.</p>

<ul>
  <li>fetchDummyData : axios 를 사용하여 API 요청을 보냅니다.</li>
  <li>wrapPromise : fetchDummyData() 함수가 반환한 Promise 와 다음의 두 함수를 Lexical Scope 에 저장합니다.
    <ul>
      <li>suspender : Promise 의 결과에 따라서 상태 (status) 와 응답 (response) 를 지정합니다.</li>
      <li>read : Promise 가 정상적으로 반환되었을 경우 값을 반환하고, 그렇지 않을 경우 오류를 발생시킵니다.</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Suspense</span> <span class="na">fallback</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>데이터 로딩 중...<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">ChildComponent</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nc">Suspense</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Suspense 의 fallback 속성을 통해서 데이터가 DOM 에 표시되기 전까지 “데이터 로딩 중…” 이라는 문자를 출력합니다.</p>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">fetchDummyData</span><span class="p">();</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">ChildComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">dummyData</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span>

  <span class="c1">// (생략)</span>
<span class="p">}</span></code></pre></figure>

<p>위와 같이 Suspense 로 둘러싸인 컴포넌트에서는 데이터를 컴포넌트 외부에서 불러오고 실제 값은 내부에서 사용합니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199047638-52d93f94-e076-450a-8e4f-c8c673e69f0f.png" />
<em>4-3-1) Render as fetch / Suspense 를 사용할 때</em>
<br /></p>

<p><br /></p>

<p><strong> [4-3-1) Render as fetch / Suspense 를 사용할 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">14ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">4ms</td>
      <td style="text-align: center">5ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">16ms</td>
      <td style="text-align: center">during-mount</td>
      <td style="text-align: center">55ms</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">18ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">5ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">72ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">13ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">89ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">94ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">99ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">104ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">109ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: center">114ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">119ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">3ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
    <tr>
      <td style="text-align: center">12</td>
      <td style="text-align: center">121ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">4ms</td>
      <td style="text-align: center">172ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">during-mount</code> 라는 이벤트를 통해서 API 요청을 받기까지 약 55ms 가 걸린 것을 확인할 수 있습니다. 또한 총 2번의 commit 이 발생하는데 첫 번째 commit 은 fallback UI 를 렌더링하는 이벤트이고 두 번째 commit 은 최종적인 데이터 목록을 렌더링하는 이벤트임을 짐작할 수 있습니다.</p>

<p><br /></p>

<h4 id="4-3-2-데이터를-두-개-불러올-때">4-3-2) 데이터를 두 개 불러올 때</h4>

<p>Suspense 를 사용하여 데이터를 여러 개 불러올 때도 fallback UI 를 사용할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="k">return</span> <span class="p">(&lt;&gt;</span>
  <span class="p">&lt;</span><span class="nc">Suspense</span> <span class="na">fallback</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>데이터 로딩 중...<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">}</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nc">ChildPhotoList</span> <span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nc">Suspense</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nc">Suspense</span> <span class="na">fallback</span><span class="p">=</span><span class="si">{</span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>데이터 로딩 중...<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">}</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nc">ChildCommentList</span> <span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nc">Suspense</span><span class="p">&gt;</span>
<span class="p">&lt;/&gt;);</span></code></pre></figure>

<p>여러 개의 Suspense 를 사용할 때에는 다음과 같이 순차적으로 배치하면 됩니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199050041-5726631d-c3dc-4fa6-9a6e-9a7152795eb3.gif" />
<em>두 개의 데이터 중 로딩이 완료된 데이터 (하단) 부터 표시되는 것을 확인할 수 있습니다.</em>
<br /></p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199048186-659790b3-2f0b-4163-8aa9-2ef29774463a.png" />
<em>4-3-2) Render as fetch / 데이터를 두 개 불러올 때</em>
<br /></p>

<p><br /></p>

<p><strong> [4-3-2) Render as fetch / 데이터를 두 개 불러올 때] </strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이벤트 순서</th>
      <th style="text-align: center">타임스탬프</th>
      <th style="text-align: center">이벤트 유형</th>
      <th style="text-align: center">실행시간</th>
      <th style="text-align: center">일괄 처리 시간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">29ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">6ms</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">33ms</td>
      <td style="text-align: center">during-mount</td>
      <td style="text-align: center">34ms</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">34ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">6ms</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">68ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">40ms</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">75ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">4ms</td>
      <td style="text-align: center">40ms</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">79ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">2ms</td>
      <td style="text-align: center">40ms</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">108ms</td>
      <td style="text-align: center">passive-effects</td>
      <td style="text-align: center">1ms</td>
      <td style="text-align: center">40ms</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">108ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">12ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center">121ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: center">127ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">132ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">12</td>
      <td style="text-align: center">138ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">144ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">14</td>
      <td style="text-align: center">152ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">9ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">161ms</td>
      <td style="text-align: center">render</td>
      <td style="text-align: center">5ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
    <tr>
      <td style="text-align: center">16</td>
      <td style="text-align: center">166ms</td>
      <td style="text-align: center">commit</td>
      <td style="text-align: center">3ms</td>
      <td style="text-align: center">61ms</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>앞서 <code class="language-plaintext highlighter-rouge">4-3-1) Suspense 를 사용할 때</code> 에서 2번의 commit 이 일어났다면, 이번에는 추가로 한 번 더 commit 이 발생합니다. 이는 두 개의 Suspense 내부에서 데이터 로딩을 완료한 각 하위 컴포넌트가 렌더링되기 때문입니다. 한편 각 render 이벤트의 실행시간은 한 번의 API 요청을 보냈을 때와 큰 차이가 없는 것을 확인할 수 있습니다.</p>

<hr />

<h2 id="5-concurrent-mode-hooks">5. Concurrent Mode Hooks</h2>

<p>React 의 함수형 컴포넌트 안에서 반환값에 사용하고 싶은 변수에 useState 를 사용할 수 있습니다. state 가 변하면 새로운 state 를 반영하기 위해서 컴포넌트가 리렌더링 됩니다. 하지만 해당 state 를 참조하는 DOM 노드가 너무 많이 존재하거나 state 의 변화가 지나치게 빈번하게 일어날 때에는 이를 실시간으로 반영하면서 발생하는 Reflow 나 Repaint 가 브라우저에 부담이 되어 렌더링 퍼포먼스를 저하시킬 수 있습니다.</p>

<p><br /></p>

<p>이를 해결하기 위해서 React 의 동시성 모드는 useTransition 과 useDeferredValue 라는 두 가지 Hook 을 제공합니다. 이러한 Hook 을 사용했을 때와 사용하지 않았을 때의 코드 결과를 테스트해보겠습니다. 1만 개의 &lt;div&gt; 태그 안에 0으로 초기화된 state 를 표시하고 1초마다 1씩 증가하는 코드를 10초동안 실행하는 방식으로 테스트를 진행했습니다.</p>

<p><br /></p>

<h3 id="5-1-usestate">5-1) useState</h3>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">BasicUseState</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">inputNumber</span><span class="p">,</span> <span class="nx">setInputNumber</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">interval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setInputNumber</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">interval</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">10000</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// (생략)</span>
<span class="p">};</span></code></pre></figure>

<p>컴포넌트가 마운트되면 setInterval 내부의 setInputNumber() 함수가 1초마다 실행됩니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199054432-841f7572-3744-4dbb-b764-068408a0fb9d.gif" />
<em>useState 로 state 가 1초마다 바뀌면서 리렌더링이 일어나는 것을 확인할 수 있습니다.</em>
<br /></p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199229576-70117a0f-0986-423f-a29d-3fdc98000d3b.png" />
<em>5-1) useState</em>
<br /></p>

<p><br /></p>

<h3 id="5-2-usetransition">5-2) useTransition</h3>

<p>useTransition 은 컴포넌트 내 state 의 업데이트 우선순위를 낮춰서 리렌더링을 늦게 발생시키는 역할을 합니다. 다음의 두 가지 값을 반환합니다.</p>
<ul>
  <li>초기값으로 전달한 state 가 업데이트 되었는지를 나타내는 boolean 값</li>
  <li>업데이트를 지연시키고 싶은 state 를 감싸는 startTransition() 함수</li>
</ul>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Transition</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">inputNumber</span><span class="p">,</span> <span class="nx">setInputNumber</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">pending</span><span class="p">,</span> <span class="nx">startTransition</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useTransition</span><span class="p">();</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">interval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">startTransition</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setInputNumber</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">interval</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">10000</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// (생략)</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">5-1)</code> 과 동일한 구조로 되어 있지만 startTransition() 함수가 inputNumber 의 Setter 함수를 감싸고 있습니다.</p>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="k">return</span> <span class="p">(</span>
  <span class="p">&lt;&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>아래에 입력값이 표시됩니다.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="si">{</span><span class="nx">pending</span> <span class="p">?</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        Pending is <span class="p">&lt;</span><span class="nt">strong</span><span class="p">&gt;</span>True<span class="p">&lt;/</span><span class="nt">strong</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">)</span> <span class="p">:</span> <span class="p">(</span>
      <span class="nx">DUMMY_ARRAY</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">_</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">index</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">inputNumber</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;)</span>
    <span class="p">)</span><span class="si">}</span>
  <span class="p">&lt;/&gt;</span>
<span class="p">);</span></code></pre></figure>

<p>또한 JSX 의 반환값에서 변수 <code class="language-plaintext highlighter-rouge">pending</code> 을 사용하여 바뀐 state 가 DOM 에 반영되지 않았을 때 표시할 fallback UI 를 정의합니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199054184-bf17fab8-1e77-4133-961c-be1f3f4a4475.gif" />
<em>1초마다 state 가 바뀌지만 업데이트되기 전에 pending 이 true 가 되면서 fallback UI 가 나타납니다.</em>
<br /></p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199229581-b9b5907f-23f4-446e-a94f-8112686db10c.png" />
<em>5-2) useTransition</em>
<br /></p>

<p><br /></p>

<h3 id="5-3-usedeferredvalue">5-3) useDeferredValue</h3>

<p>useDeferredValue 도 앞서 useTransition 과 동일하게 state 의 업데이트 우선순위를 낮추어서 자주 발생하는 state 변화에 대응하는 Hook 입니다. useTransition 이 startTransition() 과 같은 함수를 제공하여 우선순위를 낮추고자 하는 state 를 감싸는 방식으로 작성되었다면, useDeferredValue 는 선언 시에 state 를 초기값으로 전달합니다. 이후 해당 값의 업데이트 우선순위가 낮아지게 됩니다. 다만, state 의 업데이트 여부를 감지하는 변수는 제공되지 않습니다.</p>

<figure class="highlight"><pre><code class="language-jsx" data-lang="jsx"><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">DeferredValue</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">inputNumber</span><span class="p">,</span> <span class="nx">setInputNumber</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">deferredValue</span> <span class="o">=</span> <span class="nx">useDeferredValue</span><span class="p">(</span><span class="nx">inputNumber</span><span class="p">);</span>

  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">interval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">setInputNumber</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>

    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">interval</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">10000</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[]);</span>

  <span class="c1">// (생략)</span>
<span class="p">}</span> </code></pre></figure>

<p>useDeferredValue Hook 에서 inputNumber 를 초기값으로 지정하여 렌더링 우선순위를 낮춥니다. 이후 해당 값을 사용하는 DOM 노드들은 업데이트가 지연됩니다.</p>

<p><br />
<img src="https://user-images.githubusercontent.com/31645195/199229591-f59d2b6f-4c3c-44bf-8b65-924fad3a00e3.png" />
<em>5-3) useDeferredValue</em>
<br /></p>

<h3 id="5-4-concurrent-mode-hooks-정리">5-4) Concurrent Mode Hooks 정리</h3>

<p>Concurrent Mode Hooks 테스트에서는 다른 테스트 결과처럼 별도의 render 나 commit 의 실행 시간에 대해서 다루지 않았습니다. useTransition 과 useDeferredValue 에 대해서 설명할 때 업데이트 우선순위를 낮춘다는 표현을 사용했습니다. Profiler 에서는 이와 관련하여 실행 시간보다 더 중요한 정보인 <code class="language-plaintext highlighter-rouge">lanes</code> 라는 데이터를 제공합니다.</p>

<p><br /></p>

<p>lanes 는 React 의 <code class="language-plaintext highlighter-rouge">재조정</code> (Reconciliation : DOM 을 재구성하는 과정을 가리킴) 엔진인 <code class="language-plaintext highlighter-rouge">fiber</code> 에서 사용하는 값으로, 업데이트의 우선순위를 나타내는 숫자입니다. 각 작업 유형에 따라서 도로에 있는 차선같이 다양한 lanes 가 있고 각각의 우선순위가 존재합니다. 재조정이나 fiber 에 대해서 다루기에는 양이 매우 방대하기 때문에 lanes 에 대한 특징만을 간단하게 정리하면 다음과 같습니다.</p>

<ul>
  <li>32비트로 작업의 우선순위를 나타냅니다.</li>
  <li>자손에 대한 우선순위는 childLanes 에 저장됩니다.</li>
  <li>lanes 값과 우선순위는 반비례합니다.</li>
</ul>

<p><br /></p>

<p>따라서 이러한 lanes 가 1일 경우 가장 높은 우선순위를 가지게 됩니다. 다음은 동시성 모드 테스트 결과에서 확인할 수 있는 lanes 정보를 정리하여 나타낸 것입니다.</p>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">테스트 번호</th>
      <th style="text-align: center">Hook</th>
      <th style="text-align: center">lanes (1)</th>
      <th style="text-align: center">lanes (2)</th>
      <th style="text-align: center">lanes (3)</th>
      <th style="text-align: center">lanes (4)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">5-1</td>
      <td style="text-align: center">useState</td>
      <td style="text-align: center">16</td>
      <td style="text-align: center">16</td>
      <td style="text-align: center">16</td>
      <td style="text-align: center">16</td>
    </tr>
    <tr>
      <td style="text-align: center">5-2</td>
      <td style="text-align: center">useTransition</td>
      <td style="text-align: center">16</td>
      <td style="text-align: center">64</td>
      <td style="text-align: center">128</td>
      <td style="text-align: center">256</td>
    </tr>
    <tr>
      <td style="text-align: center">5-3</td>
      <td style="text-align: center">useDeferredValue</td>
      <td style="text-align: center">64</td>
      <td style="text-align: center">128</td>
      <td style="text-align: center">256</td>
      <td style="text-align: center">512</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>위의 표에서 확인할 수 있듯이 useState 만 사용한 경우에는 lanes 가 일정하게 16으로 고정되어 있는 것을 확인할 수 있었습니다. 나머지 Concurrent Mode 의 두 Hook 은 서로 값이 다르긴 하지만 점차 lanes 가 높아지는 것을 알 수 있습니다. 즉, lanes 값이 높아지기 때문에 우선순위가 낮아져 업데이트를 지연시키는 원리가 작동한다는 것을 확인할 수 있습니다.</p>

<hr />

<h2 id="6-결론">6. 결론</h2>

<ul>
  <li>React Profiler 탭에서 React 와 각 컴포넌트의 이벤트를 확인할 수 있습니다.</li>
  <li>Data Fetching 방식에는 세 가지 방법이 있습니다.
    <ol>
      <li>Fetch on render
        <ul>
          <li>컴포넌트가 마운트된 뒤에 데이터를 불러옵니다.</li>
          <li>늦은 DOM 업데이트를 통해서 사용자 경험을 해칠 수 있습니다.</li>
          <li>Layout Shift 가 일어날 가능성이 높습니다.</li>
        </ul>
      </li>
      <li>Fetch then render
        <ul>
          <li>컴포넌트 호출보다 데이터를 먼저 불러오기 시작합니다.</li>
          <li>여러 개의 서로 다른 API 요청을 보낼 때 비효율적일 수 있습니다.</li>
        </ul>
      </li>
      <li>Render as fetch
        <ul>
          <li>컴포넌트와 데이터를 동시에 불러옵니다.</li>
          <li>React Suspense 에서는 데이터 로딩 중 렌더링 할 fallback UI 를 지정할 수 있습니다.</li>
          <li>여러 개의 Suspense 를 사용할 수 있습니다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>React 의 state 를 참조하는 DOM 노드가 많고 값이 빈번하게 바뀔 경우 성능이 저하됩니다.</li>
  <li>동시성은 작업을 잘게 나누고 빠르게 번갈아 가면서 수행하는 것을 말합니다.</li>
  <li>React Concurrent Mode 에서는 두 가지 Hook 을 제공합니다.
    <ol>
      <li>useTransition
        <ul>
          <li>startTransition() 함수 내부에 정의된 state Setter 함수의 우선순위가 낮아집니다.</li>
        </ul>
      </li>
      <li>useDeferredValue
        <ul>
          <li>초기값으로 전달한 state 의 업데이트 우선순위가 낮아집니다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>위 두 Hook 이 우선순위를 낮추는 방법은 fiber 가 해석하는 lanes 의 값을 증가시키는 것입니다.</li>
</ul>

<hr />

<h2 id="7-생각해볼-점">7. 생각해볼 점</h2>

<ul>
  <li>각 테스트 케이스 별 실행 시간 차이가 정말로 의미있는 차이를 보이는 것인지 생각해볼 필요가 있습니다.</li>
  <li>테스트를 진행할 때 브라우저에 캐싱되어 있는 데이터를 불러오는 것은 아닌지 테스트하는 방법을 생각해볼 수 있습니다.</li>
  <li>다양한 Data Fetching 방법과 동시성 모드를 실제 구현 단계에서 어떻게 적재적소에 사용할 수 있을지 고민해보아야 합니다.</li>
  <li>React 의 재조정 알고리즘과 fiber 의 내부 구조에 대해서 알아두면 작동 원리를 이해하는 데에 좋을 것 같습니다.</li>
</ul>

<hr />

<p>[출처 &amp; 참고]</p>

<ul>
  <li>
    <p><a href="https://godsenal.com/posts/Javascript%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-Event-loop/">Javascript에서의 동시성과 Event loop</a></p>
  </li>
  <li>
    <p><a href="https://velog.io/@cadenzah/react-concurrent-mode">What is React Concurrent Mode?</a></p>
  </li>
  <li>
    <p><a href="https://17.reactjs.org/docs/concurrent-mode-reference.html#suspenselist">Concurrent Mode API Reference (Experimental) - React</a></p>
  </li>
  <li>
    <p><a href="https://developer-alle.tistory.com/428">React Suspense 이해하기</a></p>
  </li>
  <li>
    <p><a href="https://blog.logrocket.com/react-suspense-data-fetching/#fetch-on-render">Experimental React: Using Suspense for data fetching - LogRocket Blog</a></p>
  </li>
  <li>
    <p><a href="https://jser.dev/react/2022/06/19/how-does-suspense-list-work.html">How does SuspenseList work in React? React Source Code Walkthrough 25</a></p>
  </li>
  <li>
    <p><a href="https://dev.to/okmttdhr/what-is-lane-in-react-4np7">What is “Lane” in React?</a></p>
  </li>
  <li>
    <p><a href="https://jser.dev/react/2022/03/26/lanes-in-react.html">What is Lanes in React source code? - React Source Code Walkthrough 21</a></p>
  </li>
  <li>
    <p><a href="https://blog.shahednasser.com/how-to-use-transitions-in-react-18/">How to use Transitions in React 18</a></p>
  </li>
  <li>
    <p><a href="https://velog.io/@katanazero86/React-18-%EC%97%90%EC%84%9C-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94%EC%A0%90">React 18 에서 달라지는점</a></p>
  </li>
  <li>
    <p><a href="https://itchallenger.tistory.com/654">3분 리액트 - React18의 useTransition, useDeferredValue</a></p>
  </li>
  <li>
    <p><a href="https://vroomfan.tistory.com/45">React 18 useDeferredValue로 성능 최적화하기</a></p>
  </li>
  <li>
    <p><a href="https://velog.io/@brgndy/%EB%A6%AC%EC%95%A1%ED%8A%B8-useTransition-useDeferredValue-%EC%A0%95%EB%A6%AC">리액트 useTransition, useDeferredValue 정리</a></p>
  </li>
  <li>
    <p><a href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue">Hooks API Reference - React</a></p>
  </li>
</ul>

<p><br /></p>

<p>[코드 링크]</p>
<ul>
  <li><a href="https://github.com/iyu88/React-Concurrent-Mode">https://github.com/iyu88/React-Concurrent-Mode</a></li>
</ul>

<p><br /></p>

    </article>

    
    
    <section class="tags">
      <strong>Tags:</strong> <a href="/tag/React">
        React</a>,&nbsp;<a href="/tag/concurrentMode">
        concurrentMode</a>,&nbsp;<a href="/tag/dataFetching">
        dataFetching</a>,&nbsp;<a href="/tag/Suspense">
        Suspense</a>,&nbsp;<a href="/tag/useTransition">
        useTransition</a>,&nbsp;<a href="/tag/useDeferredValue">
        useDeferredValue</a>
    </section>
    
    

    <hr />

    <section>
      <script src="https://utteranc.es/client.js" repo="iyu88/iyu88.github.io" issue-term="pathname" label="utterances" theme="preferred-color-scheme" crossorigin="anonymous" async>
      </script>
    </section>

    <!-- <section class="share">
      <span>Share: </span>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="//www.linkedin.com/shareArticle?mini=true&url=%0A++++++http%3A%2F%2Flocalhost%3A4000%0A++++++%0A++++++%2Freact%2F2022%2F11%2F01%2Freact-concurrent-mode.html" onclick="window.open(this.href, 'linkedin-share', 'width=550,height=255');return false;">
        <i class="fa fa-linkedin-square fa-lg"></i>
      </a>
      
      
      
      
      
    </section> -->

    

  </div>
</div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h3 class="footer-heading">
      구멍을 외면하지 말자
    </h3>

    <div class="site-navigation">

      <p><strong>Site Map</strong></p>
      <ul class="pages">
        
	

	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </div>

    <div class="site-contact">

      <p><strong>Contact</strong></p>
      <ul class="social-media-list">
        <li>
          <a href="mailto:iyu88887@gmail.com">
            <i class="fa fa-envelope-o"></i>
            <span class="username">
              iyu88887@gmail.com</span>
          </a>
        </li>

        
        
        <li>
          <a href="https://github.com/iyu88" title="https://github.com/iyu88">
            <i class="fa fa-github"></i>
            <span class="username">
              iyu88</span>
          </a>
        </li>
        
        
        
        <li>
          <a href="www.linkedin.com/in/현빈-이-66710325b" title="Connect with me on LinkedIn">
            <i class="fa fa-linkedin"></i>
            <span class="username">
              HyunBin Lee</span>
          </a>
        </li>
        
        

      </ul>
    </div>

    <div class="site-signature">
      <p class="rss-subscribe text"><strong></strong></p>
      <p class="text">
        first Dev blog

      </p>
    </div>

  </div>

</footer>

<!-- Scripts -->
<script src="//code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.1/js/lightbox.min.js"></script>
<script src="//unpkg.com/popper.js@1"></script>
<script src="//unpkg.com/tippy.js@5"></script>

<script type="text/javascript">
  $(document).ready(function() {
    // Default syntax highlighting
    hljs.initHighlightingOnLoad();

    // Header
    var menuToggle = $('#js-mobile-menu').unbind();
    $('#js-navigation-menu').removeClass("show");
    menuToggle.on('click', function(e) {
      e.preventDefault();
      $('#js-navigation-menu').slideToggle(function() {
        if ($('#js-navigation-menu').is(':hidden')) {
          $('#js-navigation-menu').removeAttr('style');
        }
      });
    });

    // Enable tooltips via Tippy.js
    if (Array.isArray(window.tooltips)) {
      window.tooltips.forEach(function(tooltip) {
        var selector = tooltip[0];
        var config = tooltip[1];
        tippy(selector, config);
      })
    }
  });
</script>




<!-- Google Analytics -->
<script>
  (function(i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function() {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-243662455-3', 'auto');
  ga('send', 'pageview', {
    'page': '/react/2022/11/01/react-concurrent-mode.html',
    'title': '[React] React Concurrent Mode - Data fetching, Suspense, React hook'
  });
</script>


  </body>

</html>
